<?php

/**
 * @file
 * Contains sdv_mapeditor.module.
 */

use Drupal\Component\Serialization\Json;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Form\FormStateInterface;


/**
 * Implements hook_help().
 */
function sdv_mapeditor_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the sdv_mapeditor module.
    case 'help.page.sdv_mapeditor':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('SDV Mapeditor') . '</p>';
      return $output;

    default:
  }
}

/**
 * Implements hook_theme().
 */
function sdv_mapeditor_theme() {
  return [
    'sdv_mapeditor' => [
      'render element' => 'children',
    ],
  ];
}


/**
 * Implements hook_form_alter().
 *
 * Sets the right libraries and passes data to javascript functions about
 * several sources of layers.
 *
 * The layers for each layer-type are read from different sources:
 *     - WMS:          The layers are read from the geo-server via a
 * GetCapabilities request
 *     - URL:          The layer has its own URL
 *
 */

function sdv_mapeditor_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if ($form_id == 'sdv_map_add_form' || $form_id == 'sdv_map_edit_form') {

    // Hides the entity status field.
    $form['status']['#access'] = FALSE;

    // Toggles the parameters and layer definitions fields.
    $form['show'] = [
      '#type' => 'checkbox',
      '#title' => t('Show parameters and layer definitions'),
      '#weight' => 4,
    ];
    $form['gis_ia_layers']['#states'] = [
      'invisible' => [
        ':input[name="show"]' => ['checked' => FALSE],
      ],
    ];
    $form['gis_ia_params']['#states'] = [
      'invisible' => [
        ':input[name="show"]' => ['checked' => FALSE],
      ],
    ];
  }

  // Attaches the drupal library.
  $form['#attached']['library'][] = 'sdv_mapeditor/sdv_gis_edit';

  // Passes wms XML file content as JavaScript variables;
  $xml = simplexml_load_file('https://geodata.rivm.nl/geoserver/wms?VERSION=1.1.1&REQUEST=GetCapabilities');
  $wms = '';
  if ($xml->Capability->Layer) {
    foreach ($xml->Capability->Layer->children() as $layer) {
      $name = $layer->Name;
      $title = $layer->Title;
      if ($name != '') {
        $wms .= ($wms == '' ? '' : '|') . $name . '=' . $title;
      }
    }
  }
  $form['#attached']['drupalSettings']['gis_ia']['wms'] = $wms;
  $urls = \Drupal::config('sdv_gis.sdv_gis')->get('urls');
  $form['#attached']['drupalSettings']['gis_ia']['urls'] = $urls;
}


/**
 * Implements hook_page_attachments().
 */
function sdv_mapeditor_page_attachments(array &$attachments) {
  //  $manager = \Drupal::service('sdv_mapeditor.download_url');
  //  $files = $manager->list('public://gis_ia');
//  $attachments['#attached']['library'][] = 'sdv_mapeditor/sdv_gis';
//  $attachments['#attached']['library'][] = 'sdv_mapeditor/sdv_gis_edit';
}


/**
 * Add dynamic library definitions.
 *
 * Modules may implement this hook to add dynamic library definitions. Static
 * libraries, which do not depend on any runtime information, should be declared
 * in a modulename.libraries.yml file instead.
 *
 * @return array[]
 *   An array of library definitions to register, keyed by library ID. The
 *   library ID will be prefixed with the module name automatically.
 *
 * @see core.libraries.yml
 * @see hook_library_info_alter()
 */
function sdv_mapeditor_library_info_build() {
  // Converts config to list of libraries.
  $config = \Drupal::config('sdv_mapeditor.settings');
  $libraries = [];
  $config_libraries = Json::decode($config->get('libraries'));
  foreach ($config_libraries as $key => $library) {
    $libraries[$key] = [
      'version' => $config->get('version'),
    ];
    if (isset($library['css'])) {
      foreach ($library['css'] as $css) {
        $libraries[$key]['css']['layout'][$css] = [];
      }
    }
    if (isset($library['js'])) {
      foreach ($library['js'] as $js) {
        $libraries[$key]['js'][$js] = [];
      }
    }
    if (isset($library['dependencies'])) {
      foreach ($library['dependencies'] as $dependency) {
        $libraries[$key]['dependencies'][] = $dependency;
      }
    }
  }
  return $libraries;
}
